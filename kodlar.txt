inline styling
<div style={{ backgroundColor: 'red' }}></div>

////////////////////////////////////////////////////////////////////////////////////

export default ComponentName
bu kod ile export edebilirsin

////////////////////////////////////////////////////////////////////////////////////

<ApprovalCard>
    <CommentDetail author={names[0]} time={times[0]} content={contents[0]} />
</ApprovalCard>
Şeklinde parenttan childa data gönderebiliriz
Diğer component ise {props.children} ile bunu alır.
class ise constructor(props) ile alır super(props) yapar
fonskyion ise const myFunc = (props) => {} şeklinde alır

////////////////////////////////////////////////////////////////////////////////////

class component
constructor(props){
        super(props);               
}      
state = { lat: null, errorMessage: ' ' }; 

update ederken
this.setState({ lat: position.coords.latitude }) => burda tekrar render çalışır            


////////////////////////////////////////////////////////////////////////////////////

COMPONENT LIFECYCLE

constructor(){}: İlk başlangıçta çalışır kesinlikle
render(){} : JSX dosyası üretir
componentDidMount(){}: Ekrana data gittiğinde çalışır
componentDidUpdate(){}: State güncellendiğinde çalışır ve tekrar render çalışır
componentWillUnmount(){}: Componenti ekrandan silerken temiz cleanup yapıyor

////////////////////////////////////////////////////////////////////////////////////

<i className={`${iconName} icon massive`}></i>
Hem js variable hemde class adı koyma

////////////////////////////////////////////////////////////////////////////////////

Props Default Values
ComponentName.defaultProps = {
    PropName: 'Loading...'
};

////////////////////////////////////////////////////////////////////////////////////

Render'ın içinde IF bloğu kullanma Helper fonksiyonu kullan ve renderda bunu çağır
renderContent helper fonksiyonumuz if koşulları var

renderContent(){
    if (this.state.lat != null){
        return (
                <SeasonDisplay lat={this.state.lat} />
        );
    } else {
        return (
                <Loading message='Please Accept Location Request' />
        )
    }
}

<div className="ui">
    {this.renderContent()}
</div>

////////////////////////////////////////////////////////////////////////////////////

INPUTTAN GELEN YAZIYI ALMA
!!EVENT HANDLER DURUMLARINDA CALLBACK FONKSIYONUNA CAĞRI YAPARKEN () KULLANMA
<input type="text" name="search" onChange={(e) => console.log(e.target.value)}/> => Bu alternatif
<input type="text" name="search" onChange={this.onInputChange}/>
onInputChange = (e) => {
    console.log(e.target.value);
};

////////////////////////////////////////////////////////////////////////////////////

Bu şekilde yaparsak kontrollü almış oluruz mesela sadece büyük harf gözüküyor burda
state = { term: '' };
<input 
    type='text'
    value={this.state.term} 
    onChange={(e)=> this.setState({term: e.target.value.toUpperCase()})}
/>

////////////////////////////////////////////////////////////////////////////////////

state'yi fonksiyonda kullanmak -> cannot read property state of undefined hatası

HATA
<form onSubmit={this.onFormSubmit} className="ui form"> ->form submitlendiğinde onFormSubmit çalışacak
onFormSubmit(e) {
    e.preventDefault();
    console.log(this.state);
}

ÇÖZÜM 1: fonkisyonu arrow fonksiyon yap, form aynı kalsın
onFormSubmit = (e) => {
    e.preventDefault();
    console.log(this.state.term);
}

ÇÖZÜM 2: form içinden arraw ile gönder, fonksyion aynı kalsın
<form onSubmit={(e) => this.onFormSubmit(e)}

////////////////////////////////////////////////////////////////////////////////////

Listeyi bastırmak

const images = ImageList.map((img) => {     //Alttaki kod ile html dosyalarını liste halinde oluşturuyorsun ImageList listesinde

    return <img key={img.id} alt={img.description} src={img.urls.regular} style={{height:'200px', width: 'auto', objectFit: 'cover' }}/>
});

return <div> {images} </div>

////////////////////////////////////////////////////////////////////////////////////

Bir HTML Tagi ReactRef ile kontrol etmek, SADECE CLASS COMPONENTSTA YAPILIR


constructor(props) {
    super(props);
    this.state = { spans: 0 };
    this.imageRef = React.createRef();  // this.imageRef oluştur.
}

componentDidMount(){    // sayfa ilk yüklendiğinde
    this.imageRef.current.addEventListener('load',() => {   //tag yüklendiğinde 
        const height = this.imageRef.current.clientHeight;
        const spans = Math.ceil(height / 10);
        this.setState({ spans: spans });    // setState yap ki tekrar render edilsin
    } );
};

<div style={{ gridRowEnd: `span ${this.state.spans}`}}>     // dive bu şekilde style verebiliyorsun
<img ref = {this.imageRef} />   //bu şekilde img tagini referans alıyoruz

////////////////////////////////////////////////////////////////////////////////////

REACT HOOK - USE STATE (this.state, this.setState)

fonksiyon componentlara state, lifecycle ve ref özellikleri kazandırmaya yarıyor

state ve setState tanımlamaları
const [activeIndex, setActiveIndex] = useState(0);  
// useState(0) default değeri 0 yapıyor şuan
// burda activeIndex stateteki değerimiz
// setActiveIndex te onun fonksiyonu setFonksiyonu
// setActiveIndex(5) diyerek herhangi bir yerde set yapabiliyoruz
// multiple value için multiple yazıcaksın yukarıdaki kodu

////////////////////////////////////////////////////////////////////////////////////

REACT HOOK - USE EFFECT (componentDidMount, componentDidUpdate)

useEffect(() => { ... });   
//bu şekilde ise ilk render edildiğinde ve sonraki her renderda
//çalışır bu fonksiyon

useEffect(() => { ... },[]);
//bu şekilde ise ilk render edildiğinde çalışır sadece

useEffect(() => { ... }),[data, data2];
// bu şekilde ise ilk renderda ve data veya data2 değeri değiştiğinde çalışır


// useEffect FONKSYIONU CLEANUP FONKSIYONU DÖNEBİLİYOR AMA BU FONKSIYONU
// useEffect bir sonraki çağırıldığında bu çağırılandan önce çalışıyor
useEffect(() => {

    .
    .
    .

    return(() => {

    })

})


//USE EFFECT'İ  ASYNC OLARAK TANIMLAYAMIYORUZ. AŞAĞIDAKİ ŞEKİLDE YAPABİLİRİZ ALMA
//ASYNC SEARCH FONKSIYONU OLUŞTUR useEffect İÇİNDE SONRA ONU ÇALIŞTIR
useEffect(() => {
    const search = async () => {
        const result = await axios.get("https://en.wikipedia.org/w/api.php", {
            params: {
                action: 'query',
                list: 'search',
                origin: '*',
                format: 'json',
                srsearch: input
            }
        });
        setResults(result.data.query.search);
    }
    search();
}, [input]);

////////////////////////////////////////////////////////////////////////////////////

REACT HOOK USEREF

const ref = useRef(); // OLARAK TANIMLA FONKSİYON İÇİNDE
<div className="ui form" ref={ref}> // HTML İÇİNDE BÖYLE TANIMLA
// ref.current diyerek kontrol edebilirsin

////////////////////////////////////////////////////////////////////////////////////

HTML KODUNU JSXE İŞLEME

myText stringimizin içinde html tagleri varsa, bunu html kodu olarak göstermek için
<span dangerouslySetInnerHTML={{__html: myText}}> 
</span>

////////////////////////////////////////////////////////////////////////////////////

Sitedeki anlık urli alma veya urli değiştirme

window.location.pathname    //ile /books kısmını alabiliyoruz
window.location.href        //ile tam urli alabiliyoruz

window.history.pushState({},'', '/authors');    //ile /authorsa gönderiyor


////////////////////////////////////////////////////////////////////////////////////

Siteye bir popstate element ekleyerek diğer componentlere haber verme

const navEvent = new PopStateEvent('popstate');
window.dispatchEvent(navEvent); 
//diyoruz ki bir olay oldu navEvent windowa verildi

window.addEventListener('popstate',myFunc);   
//bununla da o eventi dinleyeilm gerçekleştiğinde myFunc çalışssın

////////////////////////////////////////////////////////////////////////////////////

functochild={(video) => setSelectedVideo(video)} yerine direk functochild={setSelectedVideo} yapabilirsin
child Componentte de functochild(thisVideo) desen çalışıyor.

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


REACT REDUX

ACTIONS, REDUCERS DOSYALARI OLUŞTUR, İKİSİNDE DE SADECE INDEX.JS OLSUN
ACTIONS STATELERDEKİ SETSTATE GİBİ DEĞİŞTİRME ŞEYLERİ
REDUCERS DA STATELER GİBİ VERİLERİ TUTAN KISIM

ACTIONS

ACTIONS ŞÖYLE OLUŞTUR TYPE OLSUN PAYLOADI DATA İÇERİCEK VE OBJE DÖNÜCEK
export const selectSong = (song) => {
    return {
        type: 'SONG_SELECTED',
        payload: song
    };
};


REDUCERS

REDUCERS ŞÖYLE OLUŞTUR VERİ DÖNÜCEK
const selectedSongReducer =  (selectSong=null, action) => {
    if (action.type === 'SONG_SELECTED') {
        return action.payload;
    }
    return selectSong;
};

EN SONDA BU OLUCAK VE BUNU KULLANICAKSIN
export default combineReducers({
    songs: songsReducer,
    selectedSong: selectedSongReducer
});


MAIN INDEX.JS APP COMPONENTA BÖYLE GİDECEK
<Provider store={createStore(combineReducers)}>
    <App />
</Provider>


BİR COMPONENTTEN VERİLERE ULAŞMA
const mapStateToProps = (state) => {
    return { songs: state.songs };  //STATETEN GELİCEK SONGSLARI PROP OLARAK ALMAYA YARIYOR
};

// BURDA selectSong FONSKİYONU combineReducerstaki HER REDUCERSE GÖNDERİYOR YANİ JS DOSYAMIZDA
// BU FONKSİYONU KULLANICAK SETSTATE YERİNE 
export default connect(mapStateToProps, {selectSong})(SongList);

////////////////////////////////////////////////////////////////////////////////////

REDUX-THUNK İLE ASYNC ACTION YANİ MİDDLEWARE KULLANMA

// INDEX.JS BÖYLE OLUCAK
import thunk from 'redux-thunk';
<Provider store={createStore(combineReducers, applyMiddleware(thunk))}>
    <App />
</Provider>,

// ASYNC ACTION DA BÖYLE OLUCAK
export const fetchPosts = () => async dispatch => {
    const response = await jsonPlaceholder.get('/posts');
    dispatch({ type: 'FETCH_POSTS', payload: response});
};


/////////////////////////////////////////////////////////////////////////////

REACT ROUTER

import { Router, Route, Link } from 'react-router-dom';

const One = () => {
    return  <div>
                One
                <Link to="/two">Go To Page2</Link>
            </div>
}
const Two = () => {
    return  <div>
                One
                <Link to="/">Go To Page1</Link>
            </div>
}

const App = () => {
    return (
        <div>
            <Router>
                <div>
                    <Route path="/" exact component={one} />
                    <Route path="/two" component={two} />
                </div>
            </Router>
        </div>
    )
}

/////////////////////////////////////////////////////////////////////////////

REDUX DEVTOOLS İLE DEBUG YAPARAK ÇALIŞMA, CHROME EXTENSION

import { createStore, applyMiddleware, compose } from 'redux';
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; 
const store = createStore(
    combineReducers,
    composeEnhancers(applyMiddleware())
);

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);

/////////////////////////////////////////////////////////////////////////////

REDUX FORM,
// redux form otomatik reducer, action falan yapıyor mapStateToPropsa gerek kalmıyor

//Reducerdaki index.js te şunları yapman lazım form olarak alabilesin
import { reducer as formReducer } from 'redux-form';
export default combineReducers({
    ...(other reducers)
    form: formReducer
});


//Formu kullanacağın Componentte connect gibi bağlıcaksın
import { Field, reduxForm } from 'redux-form';

renderInput ({input, label, meta}) {
    return (
        <div className={className}>
            <label>{label}</label>
            <input {...input} autoComplete="off" /> //...input value ve onChange hallediyor
            {meta.touched && meta.error ? 'error':''} //dokundu ve hata varsa hata gösterir
        </div>
    );
}

// fielda input dönen bir component döndürmek zorundasın,
// label gibi bilmediği prop alırsa bu componente aktarır 
return (
        <form className="ui form error">
            <Field name="title" component={this.renderInput} label="Stream Title"/>
        </form> 
    </div>
);


const validate = (formValues) => {
    const errors = {};
    if(!formValues.title){
        errors.title = 'You must enter a Title';    //obje propu field name ile aynı olmalı
    };
    return errors;  // boş obje dönerse hata yok.
}   

export default reduxForm({
    form: 'streamCreate',
    validate: validate
})(StreamCreate);